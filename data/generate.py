import numpy as np
import random
import lmdb
import caffe
import sgf
import re

# How many records to print out?
# This should be less than or equal to the number of game records
# generated by the simulate.sh script.
NUM_RECORDS = 100
# Should be the same BOARD_SIZE as found in generate.sh that was used to generate
# the games directory.
BOARD_SIZE = 9

# Create the LMDB database for storing our records.
DB_NAME = "lmdb_records_" + str(NUM_RECORDS)
MAP_SIZE = 10 * NUM_RECORDS * 2 * BOARD_SIZE * BOARD_SIZE * np.dtype(np.int8).itemsize
env = lmdb.open(DB_NAME, map_size=MAP_SIZE)
txn = env.begin(write=True)

# Record a game entry to the lmdb database.
def recordentry(board, score, txn):
    datum = caffe.proto.caffe_pb2.Datum()
    datum.channels = board.shape[0]
    datum.height = board.shape[1]
    datum.width = board.shape[2]
    datum.data = board.tobytes()
    datum.label = score
    str_id = '{:08}'.format(game)
    txn.put(str_id.encode('ascii'), datum.SerializeToString())
    return

# Loop through a number of game records.
for game in range(0, NUM_RECORDS):

    # Open a file for parsing.
    filename = 'games/' + str(game) + '.sgf'
    with open(filename, 'r') as f:

        # Use a regular expression to try and find the score of the game.
        # We will compute a single value to use as a label in our training and validation sets.
        # Positive will be a black win and negative a white win.
        # This score will ignore the constant komi modifier.
        r = f.read()
        res = re.search('RE\[[BW]\+\d+.\d\]', r).group(0)[3:-1]
        kom = float(re.search('KM\[\d+.\d\]', r).group(0)[3:-1])

        # Check the winner, then rip that label off of the result, and calculate the score.
        win = res[0]
        score = float(res[2:])
        if win == 'B':
            score += kom
        else:
            score = -(score - kom)

        # Next up we need to build the array representing the game board.
        # This will be a 9x9 board with 2 channel per location.
        # White will be channel 0, Black will be channel 1.
        board = np.zeros((2, BOARD_SIZE, BOARD_SIZE), dtype=np.int8)
        game = sgf.parse(r).children[0]

        # Loop through each move of the game.
        for node in game.rest:
            # Find the move (black or white) and position
            if 'W' in node.properties:
                channel = 0
                pos = node.properties['W'][0]
            elif 'B' in node.properties:
                channel = 1
                pos = node.properties['B'][0]

            # Place the move onto the board.
            if len(pos) >= 2:
                x = ord(pos[0]) - ord('a')
                y = ord(pos[1]) - ord('a')
                board[channel][x][y] = 1

            # Include random entries from this game.
            if random.random() < 0.3:
                recordentry(board, score, txn)

        # Debug print the data we have found, this is what we will be training on.
        print(score)
        print(board[0])

